<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ShareFile P2P</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    body { font-family: 'Inter', sans-serif; }
    .blur-overlay {
      backdrop-filter: blur(10px) saturate(140%);
      background: rgba(15, 23, 42, 0.7);
    }
    .code-input {
      width: 3rem;
      height: 3rem;
      text-align: center;
      font-size: 1.5rem;
      font-weight: 600;
      border-radius: 0.375rem;
      border: 1px solid #D1D5DB;
      background-color: #F9FAFB;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .code-input:focus {
      border-color: #4F46E5;
      outline: none;
      box-shadow: 0 0 0 1px #4F46E5;
    }
  </style>
</head>
<body class="bg-slate-50 min-h-screen">

  <!-- LOGIN SCREEN -->
  <div id="login-screen" class="fixed inset-0 flex items-center justify-center blur-overlay z-50">
    <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md border-t-4 border-indigo-500">
      <div class="flex justify-center mb-4">
        <svg class="w-12 h-12 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none"
             viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round"
                d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
        </svg>
      </div>
      <h2 class="text-3xl font-bold text-center mb-2 text-slate-800">ShareFile Login</h2>
      <p class="text-center text-slate-500 mb-6 text-sm">
        Sign in to start a secure P2P file share session.
      </p>

      <label class="block font-medium mb-1 text-sm text-slate-700">Username</label>
      <input id="username" type="text"
             class="w-full px-4 py-3 rounded-md border border-gray-300 mb-4 focus:ring-2 focus:ring-indigo-500 focus:outline-none">

      <label class="block font-medium mb-1 text-sm text-slate-700">Password</label>
      <input id="password" type="password"
             class="w-full px-4 py-3 rounded-md border border-gray-300 focus:ring-2 focus:ring-indigo-500 focus:outline-none">

      <button id="login-btn"
              class="mt-6 w-full bg-indigo-600 text-white py-3 rounded-md font-semibold hover:bg-indigo-700 transition">
        Login
      </button>

      <p id="login-error" class="hidden text-red-500 text-center mt-3 text-sm">Invalid login.</p>
    </div>
  </div>

  <!-- LOADING SCREEN -->
  <div id="loading-screen" class="hidden fixed inset-0 z-50 flex items-center justify-center blur-overlay">
    <div class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-sm text-center">
      <div class="animate-spin w-10 h-10 border-4 border-indigo-600 border-t-transparent rounded-full mx-auto mb-4"></div>
      <p class="text-xl font-semibold text-slate-800">Checking login...</p>
      <p class="text-sm text-slate-500 mt-2">Please wait a moment.</p>
    </div>
  </div>

  <!-- MODE SELECT SCREEN -->
  <div id="mode-screen" class="hidden p-6 sm:p-8 max-w-xl mx-auto mt-16">
    <div class="bg-white rounded-2xl shadow-xl p-8 border border-indigo-100">
      <h2 class="text-3xl font-bold text-center mb-3 text-slate-800">Share a File</h2>
      <p class="text-center text-slate-500 mb-8">
        Choose whether you want to send or receive files.
      </p>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <button id="send-btn"
                class="bg-indigo-600 text-white py-6 rounded-xl font-semibold text-xl hover:bg-indigo-700 transition flex flex-col items-center justify-center">
          <span>Send</span>
          <span class="text-xs opacity-80 mt-1">Upload from this device</span>
        </button>

        <button id="receive-btn"
                class="bg-slate-100 text-slate-800 py-6 rounded-xl font-semibold text-xl hover:bg-slate-200 transition flex flex-col items-center justify-center">
          <span>Receive</span>
          <span class="text-xs opacity-80 mt-1">Enter code from sender</span>
        </button>
      </div>
    </div>
  </div>

  <!-- SEND FILE UPLOAD SCREEN -->
  <div id="send-upload-screen" class="hidden p-6 sm:p-8 max-w-xl mx-auto mt-16">
    <div class="bg-white rounded-2xl shadow-xl p-8 border border-indigo-100">
      <h2 class="text-2xl font-bold mb-4 text-slate-800">Select files to send</h2>
      <p class="text-slate-500 mb-4 text-sm">
        You can choose one or multiple files. They will be sent directly to the receiver via P2P.
      </p>

      <input id="file-input" type="file" multiple
             class="w-full border border-gray-300 rounded-md bg-white p-4 text-sm">

      <button id="send-continue-btn"
              class="mt-6 w-full bg-indigo-600 text-white py-3 rounded-md font-semibold hover:bg-indigo-700 transition">
        Continue
      </button>
    </div>
  </div>

  <!-- RECEIVE CODE ENTRY SCREEN -->
  <div id="code-screen" class="hidden fixed inset-0 flex items-center justify-center blur-overlay z-40">
    <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md border-t-4 border-indigo-500">
      <h2 class="text-2xl font-bold text-center mb-2 text-slate-800">Enter 3-digit code</h2>
      <p class="text-center text-slate-500 mb-6 text-sm">
        Type the code shown on the sender’s screen.
      </p>

      <div id="code-inputs" class="flex justify-center gap-3 mb-6">
        <input type="text" maxlength="1" class="code-input" data-index="0" inputmode="numeric">
        <input type="text" maxlength="1" class="code-input" data-index="1" inputmode="numeric">
        <input type="text" maxlength="1" class="code-input" data-index="2" inputmode="numeric">
      </div>

      <button id="code-connect-btn"
              class="w-full bg-indigo-600 text-white py-3 rounded-md font-semibold hover:bg-indigo-700 transition">
        Connect
      </button>

      <p id="code-error" class="hidden text-red-500 text-center mt-3 text-sm">Please enter all 3 digits.</p>
    </div>
  </div>

  <!-- WAITING / STATUS OVERLAY -->
  <div id="waiting-screen" class="hidden fixed inset-0 flex items-center justify-center blur-overlay z-30">
    <div class="bg-white p-10 rounded-2xl shadow-xl text-center max-w-md">
      <div id="waiting-title" class="text-2xl font-semibold mb-3 text-slate-800">Waiting...</div>
      <div class="animate-spin w-10 h-10 border-4 border-indigo-600 border-t-transparent rounded-full mx-auto mb-3"></div>
      <p id="waiting-message" class="text-slate-500 text-sm mb-2"></p>
      <p id="waiting-code" class="font-mono text-sm text-indigo-600"></p>
    </div>
  </div>

  <!-- RECEIVED FILES GRID -->
  <section id="received-files-section" class="hidden max-w-5xl mx-auto mt-10 px-4 pb-10">
    <div class="bg-white rounded-2xl shadow-xl p-6 border border-slate-200">
      <h2 class="text-2xl font-bold text-slate-800 mb-2">Received Files</h2>
      <p class="text-slate-500 text-sm mb-4">
        These files were received over the P2P connection. Click download on any file.
      </p>
      <div id="received-files-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        <!-- Cards injected by JS -->
      </div>
    </div>
  </section>

  <script>
    const WORKER_URL = "https://sharefile.mas0ngcloud.com";

    let pc = null;
    let dataChannel = null;
    let isSender = false;
    let sessionCode = null;

    const loginScreen = document.getElementById("login-screen");
    const loadingScreen = document.getElementById("loading-screen");
    const modeScreen = document.getElementById("mode-screen");
    const sendUpload = document.getElementById("send-upload-screen");
    const waitingScreen = document.getElementById("waiting-screen");
    const waitingTitle = document.getElementById("waiting-title");
    const waitingMessage = document.getElementById("waiting-message");
    const waitingCode = document.getElementById("waiting-code");
    const codeScreen = document.getElementById("code-screen");
    const codeInputsContainer = document.getElementById("code-inputs");
    const codeInputs = codeInputsContainer.querySelectorAll(".code-input");
    const receivedFilesSection = document.getElementById("received-files-section");
    const receivedFilesGrid = document.getElementById("received-files-grid");

    let receivedFiles = [];

    function generateSessionCode() {
      const n = Math.floor(Math.random() * 1000); // 0–999
      return n.toString().padStart(3, "0");
    }

    function waitForIceGathering(pc) {
      if (pc.iceGatheringState === "complete") return Promise.resolve();
      return new Promise((resolve) => {
        pc.addEventListener("icegatheringstatechange", () => {
          if (pc.iceGatheringState === "complete") resolve();
        });
      });
    }

    function createPeerConnection() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      pc.onconnectionstatechange = () => {
        console.log("Connection state:", pc.connectionState);
        if (pc.connectionState === "connected") {
          waitingTitle.textContent = "Connected";
        } else if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
          waitingTitle.textContent = "Connection lost";
        }
      };

      pc.onicecandidate = (event) => {
        console.log("ICE candidate:", event.candidate);
      };

      if (!isSender) {
        pc.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupReceiverDataChannel(dataChannel);
        };
      }
    }

    // LOGIN
    document.getElementById("login-btn").onclick = async () => {
      const username = document.getElementById("username").value.trim();
      const password = document.getElementById("password").value.trim();
      const errorEl = document.getElementById("login-error");

      if (!username || !password) {
        errorEl.textContent = "Please fill in username and password.";
        errorEl.classList.remove("hidden");
        return;
      }

      errorEl.classList.add("hidden");
      loginScreen.classList.add("hidden");
      loadingScreen.classList.remove("hidden");

      const minDelay = new Promise((res) => setTimeout(res, 2000));

      const req = fetch(`${WORKER_URL}/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password })
      });

      try {
        const [response] = await Promise.all([req, minDelay]);
        const data = await response.json();
        if (!response.ok || !data.ok) throw new Error("Invalid login");
        loadingScreen.classList.add("hidden");
        modeScreen.classList.remove("hidden");
      } catch (err) {
        loadingScreen.classList.add("hidden");
        loginScreen.classList.remove("hidden");
        errorEl.textContent = "Invalid login.";
        errorEl.classList.remove("hidden");
      }
    };

    // SEND FLOW
    document.getElementById("send-btn").onclick = () => {
      modeScreen.classList.add("hidden");
      sendUpload.classList.remove("hidden");
    };

    document.getElementById("send-continue-btn").onclick = async () => {
      const input = document.getElementById("file-input");
      const files = Array.from(input.files);
      if (!files.length) {
        alert("Please select at least one file.");
        return;
      }

      isSender = true;
      sessionCode = generateSessionCode();

      sendUpload.classList.add("hidden");
      waitingTitle.textContent = "Setting up P2P connection...";
      waitingMessage.textContent = "Share this 3-digit code with the receiver:";
      waitingCode.textContent = sessionCode;
      waitingScreen.classList.remove("hidden");

      createPeerConnection();

      dataChannel = pc.createDataChannel("file");
      setupSenderDataChannel(dataChannel, files);

      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIceGathering(pc);

        const localDesc = pc.localDescription;
        await fetch(`${WORKER_URL}/offer?code=${encodeURIComponent(sessionCode)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sdp: localDesc })
        });

        waitingTitle.textContent = "Waiting for receiver...";
        waitingMessage.textContent = "Receiver should enter this code on their device.";
        waitingCode.textContent = sessionCode;

        let answerSet = false;
        while (!answerSet) {
          await new Promise((res) => setTimeout(res, 10000)); // 10 seconds
          const res = await fetch(`${WORKER_URL}/answer?code=${encodeURIComponent(sessionCode)}`);
          const data = await res.json();
          if (data.ok && data.hasAnswer && data.answer) {
            const remoteDesc = new RTCSessionDescription(data.answer);
            await pc.setRemoteDescription(remoteDesc);
            answerSet = true;
            waitingTitle.textContent = "Connecting...";
            waitingMessage.textContent = "Negotiating connection with receiver.";
          }
        }
      } catch (e) {
        console.error(e);
        waitingScreen.classList.add("hidden");
        alert("Failed to set up connection: " + e.message);
        modeScreen.classList.remove("hidden");
      }
    };

    // RECEIVE FLOW
    document.getElementById("receive-btn").onclick = () => {
      modeScreen.classList.add("hidden");
      codeScreen.classList.remove("hidden");
      setTimeout(() => {
        if (codeInputs[0]) codeInputs[0].focus();
      }, 10);
    };

    // Code input behaviour
    codeInputsContainer.addEventListener("input", (e) => {
      const target = e.target;
      const value = target.value.replace(/[^0-9]/g, "");
      target.value = value;
      const index = parseInt(target.dataset.index, 10);

      if (value && index < codeInputs.length - 1) {
        codeInputs[index + 1].focus();
      }
    });

    codeInputsContainer.addEventListener("keydown", (e) => {
      const target = e.target;
      const index = parseInt(target.dataset.index, 10);

      if (e.key === "Backspace" && !target.value && index > 0) {
        codeInputs[index - 1].focus();
      }
      if (e.key === "Enter") {
        document.getElementById("code-connect-btn").click();
      }
    });

    document.getElementById("code-connect-btn").onclick = async () => {
      const errorEl = document.getElementById("code-error");
      const code = Array.from(codeInputs).map(i => i.value).join("");

      if (code.length !== 3) {
        errorEl.classList.remove("hidden");
        return;
      }
      errorEl.classList.add("hidden");

      isSender = false;
      sessionCode = code;

      codeScreen.classList.add("hidden");
      waitingTitle.textContent = "Waiting for sender...";
      waitingMessage.textContent = "As soon as the sender’s offer is ready, we will connect.";
      waitingCode.textContent = "Code: " + sessionCode;
      waitingScreen.classList.remove("hidden");

      createPeerConnection();
      startReceiverFlow();
    };

    async function startReceiverFlow() {
      try {
        let offerReceived = false;
        let offerData = null;

        while (!offerReceived) {
          await new Promise((res) => setTimeout(res, 10000)); // 10 seconds
          const res = await fetch(`${WORKER_URL}/offer?code=${encodeURIComponent(sessionCode)}`);
          const data = await res.json();
          if (data.ok && data.hasOffer && data.offer) {
            offerData = data.offer;
            offerReceived = true;
          }
        }

        const remoteDesc = new RTCSessionDescription(offerData);
        await pc.setRemoteDescription(remoteDesc);

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await waitForIceGathering(pc);

        const localDesc = pc.localDescription;
        await fetch(`${WORKER_URL}/answer?code=${encodeURIComponent(sessionCode)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sdp: localDesc })
        });

        waitingTitle.textContent = "Connecting...";
        waitingMessage.textContent = "Negotiating connection with sender.";
      } catch (e) {
        console.error(e);
        waitingScreen.classList.add("hidden");
        alert("Failed to receive connection: " + e.message);
        modeScreen.classList.remove("hidden");
      }
    }

    // SENDER DATA CHANNEL
    function setupSenderDataChannel(channel, files) {
      channel.onopen = () => {
        waitingTitle.textContent = "Sending files...";
        waitingMessage.textContent = "Do not close this page until all files are sent.";
        waitingCode.textContent = "";
        sendFilesOverDataChannel(channel, files);
      };
      channel.onclose = () => {
        waitingTitle.textContent = "Done";
        waitingMessage.textContent = "Files sent. You can close this page.";
      };
      channel.onerror = (e) => console.error("DataChannel error", e);
    }

    async function sendFilesOverDataChannel(channel, files) {
      const chunkSize = 16 * 1024;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        waitingMessage.textContent = `Sending file ${i + 1} of ${files.length}: ${file.name}`;

        channel.send(JSON.stringify({
          type: "file-meta",
          name: file.name,
          size: file.size,
          mime: file.type || "application/octet-stream"
        }));

        let offset = 0;
        while (offset < file.size) {
          const slice = file.slice(offset, offset + chunkSize);
          const buffer = await slice.arrayBuffer();
          channel.send(buffer);
          offset += chunkSize;
        }

        channel.send(JSON.stringify({ type: "file-end" }));
      }

      waitingTitle.textContent = "All files sent";
      waitingMessage.textContent = "You can safely close this page.";
    }

    // RECEIVER DATA CHANNEL
    function setupReceiverDataChannel(channel) {
      waitingTitle.textContent = "Receiving files...";
      waitingMessage.textContent = "Files will appear below as they arrive.";
      waitingCode.textContent = "";

      let incomingFile = null;

      channel.onmessage = (event) => {
        if (typeof event.data === "string") {
          try {
            const msg = JSON.parse(event.data);
            if (msg.type === "file-meta") {
              incomingFile = {
                name: msg.name,
                size: msg.size,
                mime: msg.mime || "application/octet-stream",
                received: 0,
                chunks: []
              };
              waitingMessage.textContent = `Receiving: ${msg.name}`;
            } else if (msg.type === "file-end") {
  if (incomingFile) {
    const blob = new Blob(incomingFile.chunks, { type: incomingFile.mime });
    addReceivedFile(incomingFile, blob);
    incomingFile = null;

    // HIDE WAITING SCREEN ON FIRST RECEIVED FILE
    waitingScreen.classList.add("hidden");

    waitingMessage.textContent = "Waiting for more files or close when finished.";
  }
}

          } catch (e) {
            console.error("Error parsing message", e);
          }
        } else {
          if (incomingFile) {
            incomingFile.chunks.push(event.data);
            incomingFile.received += event.data.byteLength || event.data.size || 0;
          }
        }
      };

      channel.onclose = () => {
        waitingTitle.textContent = "Transfer complete";
        waitingMessage.textContent = "Files are listed below.";
        waitingScreen.classList.add("hidden");
      };

      channel.onerror = (e) => console.error("Receiver data channel error", e);
    }

    function addReceivedFile(meta, blob) {
      const url = URL.createObjectURL(blob);
      receivedFiles.push({
        name: meta.name,
        size: meta.size,
        mime: meta.mime,
        url
      });
      renderReceivedFilesGrid();
    }

    function renderReceivedFilesGrid() {
      if (!receivedFiles.length) {
        receivedFilesSection.classList.add("hidden");
        return;
      }
      receivedFilesSection.classList.remove("hidden");
      receivedFilesGrid.innerHTML = "";

      receivedFiles.forEach((file, index) => {
        const sizeKB = (file.size / 1024).toFixed(1);
        const card = document.createElement("div");
        card.className = "border border-slate-200 rounded-xl p-4 flex flex-col justify-between bg-slate-50";

        card.innerHTML = `
          <div>
            <h3 class="font-semibold text-slate-800 break-words">${file.name}</h3>
            <p class="text-xs text-slate-500 mt-1">
              ${(sizeKB)} KB · ${file.mime}
            </p>
          </div>
          <button data-index="${index}"
                  class="mt-4 w-full bg-indigo-600 text-white text-sm font-semibold py-2 rounded-md hover:bg-indigo-700 transition download-btn">
            Download
          </button>
        `;

        receivedFilesGrid.appendChild(card);
      });

      receivedFilesGrid.onclick = (e) => {
        const btn = e.target.closest(".download-btn");
        if (!btn) return;
        const idx = parseInt(btn.dataset.index, 10);
        const file = receivedFiles[idx];
        if (!file) return;

        const a = document.createElement("a");
        a.href = file.url;
        a.download = file.name || "file";
        document.body.appendChild(a);
        a.click();
        a.remove();
      };
    }
  </script>
</body>
</html>
